import { Option } from './lib'

////////////////////////////////////////////////////////////////////////////////////////////////////
// ResultBase
////////////////////////////////////////////////////////////////////////////////////////////////////

/** Method prototypes for instances of the (union) {@link Result} type. */
abstract class ResultBase<T, E> {
    // can only be constructed by deriving classes
    protected constructor() { }

    /**
     * Returns `true` if the {@link Result} instance is an {@link Ok} variant.
     *
     * This methods acts as type guard.
     *
     * ## Example
     *
     * ```typescript
     * declare function getResult(): Result<number, Error>
     *
     * const res = getResult()
     * if (res.isOk()) {
     *     // not possible before narrowing!
     *     console.log(res.val)
     * }
     * ```
     *
     * @param this
     * @returns type guard determining if `this` is an {@link Ok} variant
     */
    isOk(this: Result<T, E>): this is Ok<T, never> {
        return this.tag === Tag.Ok
    }

    /**
     * Returns `true` if the {@link Result} instance is an {@link Err} variant.
     *
     * This methods acts as type guard.
     *
     * ## Example
     *
     * ```typescript
     * declare function getResult(): Result<number, Error>
     *
     * const res = getResult()
     * if (res.isErr()) {
     *     // not possible before narrowing!
     *     throw(res.err)
     * }
     * ```
     *
     * @param this
     * @returns type guard determining if `this` is an {@link Err} variant
     */
    isErr(this: Result<T, E>): this is Err<never, E> {
        return this.tag === Tag.Err
    }

    /**
     * Performs a matching operation, calling and returning the result of either `ok` or `err`
     * according the concrete variant of `this`.
     *
     * ## Example
     *
     * ```typescript
     * declare function getResult(): Result<number, Error>
     * // return type is `void` in this case
     * getResult().match(
     *     val => console.log('got ' + val),
     *     err => console.log('an error occurred')
     * )
     * ```
     *
     * @param this
     * @param ok the function called in case of an {@link Ok} variant
     * @param err the function called in case of an {@link Err} variant
     * @returns the result of the called function
     */
    match<R>(this: Result<T, E>, ok: (_: T) => R, err: (_: E) => R): R {
        switch (this.tag) {
            case Tag.Ok: return ok(this.val)
            case Tag.Err: return err(this.err)
        }
    }

    /**
     * Maps this {@link Result} to a `Result<U, E>` by applying `fn` to a contained {@link Ok}
     * value, leaving an {@link Err} value untouched.
     *
     * @param this
     * @param fn the function to be applied to a contained {@link Ok} value.
     */
    map<U>(this: Result<T, E>, fn: (_: T) => U): Result<U, E> {
        switch (this.tag) {
            case Tag.Ok: return Result.Ok(fn(this.val))
            case Tag.Err: return this as unknown as Result<U, E>
        }
    }

    /**
     * Maps this {@link Result} to a `U` instance by either calling `fn` on the contained {@link Ok}
     * value or returning the given default value.
     *
     * @param this
     * @param def the default value to return in the {@link Err} case
     * @param fn the function used to transform the contained value
     * @returns the transformed value or the given default
     */
    mapOr<U>(this: Result<T, E>, def: U, fn: (_: T) => U): U {
        return this.match(ok => fn(ok), _ => def)
    }

    /**
     * Maps this {@link Result} to a `U` instance by either calling `fn` on the contained {@link Ok}
     * value or returning the default value generated by the given `def` function.
     *
     * The difference to {@link ResultBase.mapOr} is, that the default value is lazily generated
     * only if no value is contained in `this`.
     *
     * @param this
     * @param def the function generating the default value to return in the {@link Err} case
     * @param fn the function used to transform the contained value
     * @returns the transformed value or the given default
     */
    mapOrElse<U>(this: Result<T, E>, def: () => U, fn: (_: T) => U): U {
        return this.match(ok => fn(ok), _ => def())
    }

    and<U>(this: Result<T, E>, res: Result<U, E>): Result<U, E> {
        switch (this.tag) {
            case Tag.Ok: return res
            case Tag.Err: return this as unknown as Result<U, E>
        }
    }

    andThen<U>(this: Result<T, E>, fn: (_: T) => Result<U, E>) {
        switch (this.tag) {
            case Tag.Ok: return fn(this.val)
            case Tag.Err: return this as unknown as Result<U, E>
        }
    }

    or<F>(this: Result<T, E>, res: Result<T, F>): Result<T, F> {
        switch (this.tag) {
            case Tag.Ok: return this as unknown as Result<T, F>
            case Tag.Err: return res
        }
    }

    orElse<F>(this: Result<T, E>, fn: (_: E) => Result<T, F>): Result<T, F> {
        switch (this.tag) {
            case Tag.Ok: return this as unknown as Result<T, F>
            case Tag.Err: return fn(this.err)
        }
    }

    toOk(this: Result<T, E>): Option<T> {
        switch (this.tag) {
            case Tag.Ok: return Option.Some(this.val)
            case Tag.Err: return Option.None
        }
    }

    toErr(this: Result<T, E>): Option<E> {
        switch (this.tag) {
            case Tag.Ok: return Option.None
            case Tag.Err: return Option.Some(this.err)
        }
    }

    unwrap(this: Result<T, E>): T | never {
        switch (this.tag) {
            case Tag.Ok: return this.val
            case Tag.Err: throw new UnwrapError(this.err, Tag.Ok)
        }
    }

    unwrapOr(this: Result<T, E>, def: T): T {
        switch (this.tag) {
            case Tag.Ok: return this.val
            case Tag.Err: return def
        }
    }

    unwrapOrElse(this: Result<T, E>, def: () => T): T {
        switch (this.tag) {
            case Tag.Ok: return this.val
            case Tag.Err: return def()
        }
    }

    unwrapErr(this: Result<T, E>): E | never {
        switch (this.tag) {
            case Tag.Ok: throw new UnwrapError(this.val, Tag.Err)
            case Tag.Err: return this.err
        }
    }

    expect(this: Result<T, E>, msg: string): T | never {
        switch (this.tag) {
            case Tag.Ok: return this.val
            case Tag.Err: throw new ExpectError(this.err, msg)
        }
    }

    flatten(this: Result<Result<T, E>, E>): Result<T, E> {
        switch (this.tag) {
            case Tag.Ok: return this.val
            case Tag.Err: return Result.Err(this.err)
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Tag
////////////////////////////////////////////////////////////////////////////////////////////////////

/** The {@link Result} discriminant tag type. */
export const enum Tag { Ok, Err }

////////////////////////////////////////////////////////////////////////////////////////////////////
// Ok
////////////////////////////////////////////////////////////////////////////////////////////////////

/** The {@link Result} variant representing the success case. */
export class Ok<T, E> extends ResultBase<T, E> {
    /** The discriminant tag. */
    readonly tag: Tag.Ok
    /** The contained value. */
    readonly val: T

    /** Returns a new {@link Ok} instance containing the given `val`. */
    static from<T, E>(val: T): Ok<T, E> {
        return new Ok(val)
    }

    private constructor(val: T) {
        super()
        this.tag = Tag.Ok
        this.val = val
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Err
////////////////////////////////////////////////////////////////////////////////////////////////////

/** The {@link Result} variant representing the error case. */
export class Err<T, E> extends ResultBase<T, E> {
    /** The discriminant tag. */
    readonly tag: Tag.Err
    /** The contained error. */
    readonly err: E

    /** Returns a new {@link Err} instance containing the given `err`. */
    static from<T, E>(err: E): Err<T, E> {
        return new Err(err)
    }

    private constructor(err: E) {
        super()
        this.tag = Tag.Err
        this.err = err
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Result
////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * The union type containing either an {@link Ok} or an {@link Err} variant.
 *
 * The discriminant field (`tag`) is of type {@link Tag} and the {@link Ok} variant includes an
 * additional `val` field, whereas the {@link Err} variant includes an `err` field.
 */
export type Result<T, E> = Ok<T, E> | Err<T, E>

/** Associated (static) functions for creating {@link Result} instances. */
export const Result: {
    /**
     * Creates a new {@link Ok} variant with the given `val`.
     *
     * @param val the value to be wrapped
     * @returns the {@link Some} variant
     */
    Ok: <T, E>(val: T) => Result<T, E>,
    /**
     * Creates a new {@link Err} variant with the given `err`.
     *
     * @param err the error to be wrapped
     * @returns the {@link Err} variant
     */
    Err: <T, E>(err: E) => Result<T, E>,
    /**
     * Attempts to execute `fn`, wrapping its result in an {@link Ok} variant or catches any
     * exceptions that are instances of `err`, returning them as {@link Err}.
     *
     * If an exception is caught that is not an instance of `err`, it will be re-thrown.
     *
     * @param fn the function to be executed
     * @param err the exception to be caught
     * @returns the {@link Result} wrapping either `fn`'s return value or the caught error
     * @throws any exception thrown by `fn` that is no instance of `err`
     */
    tryCatch: <T, E>(fn: () => T, err: new (...args: any[]) => E) => Result<T, E>,
} = Object.freeze({
    Ok<T, E>(val: T): Result<T, E> { return Ok.from(val) },
    Err<T, E>(err: E): Result<T, E> { return Err.from(err) },
    tryCatch<T, E>(fn: () => T, err: new (...args: any[]) => E): Result<T, E> {
        try {
            return Result.Ok(fn())
        } catch (ex) {
            if (ex instanceof err) {
                return Result.Err(ex)
            }

            throw ex
        }
    }
})

////////////////////////////////////////////////////////////////////////////////////////////////////
// UnwrapError
////////////////////////////////////////////////////////////////////////////////////////////////////

export class UnwrapError<T> extends Error {
    constructor(public val: T, expected: Tag) {
        super(expected === Tag.Ok
            ? 'called `unwrap` on an `Result.Err` value: ' + val
            : 'called `unwrapErr` on an `Result.Ok` value: ' + val
        )
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// ExpectError
////////////////////////////////////////////////////////////////////////////////////////////////////

export class ExpectError<T> extends Error {
    constructor(public val: T, msg: string) {
        super(msg + ': ' + val)
    }
}