import { Result, ResultTag } from './lib'

////////////////////////////////////////////////////////////////////////////////////////////////////
// OptionBase
////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * Method prototypes for instances of the (union) {@link Option} type.
 */
abstract class OptionBase<T> {
    protected constructor() { }

    /**
     * Returns `true` if the {@link Option} instance is a {@link Some} variant.
     *
     * # Example
     *
     * Using the `isSome` type guard to narrow the {@link Option} variant allows directly accessing
     * the contained value:
     *
     * ```ts
     * declare function getOption(): Option<string>
     *
     * if (getOption().isSome()) {
     *     // not possible before narrowing!
     *     console.log(option.val)
     * }
     * ```
     *
     * @param this
     * @returns type guard determining if `this` is a {@link Some} variant
     */
    isSome(this: Option<T>): this is Some<T> {
        return this.tag === Tag.Some
    }

    /**
     * Returns `true` if the {@link Option} instance is a {@link None} variant.
     *
     * @param this
     * @returns type guard determining if `this` is a {@link None} variant
     */
    isNone(this: Option<T>): this is None<never> {
        return this.tag === Tag.None
    }

    /**
     * Performs a matching operation, calling and returning the result of either `some` or `none`
     * according the concrete variant of `this`.
     *
     * @param this
     * @param some the function called in case of a {@link Some} variant
     * @param none the function called in case of a {@link None} variant
     * @returns the result of the called function
     */
    match<R>(this: Option<T>, some: (_: T) => R, none: () => R): R {
        switch (this.tag) {
            case Tag.Some: return some(this.val)
            case Tag.None: return none()
        }
    }

    /**
     * Maps this {@link Option} to an `Option<U>` by applying `fn` to the contained value, if there
     * is one.
     *
     * @param this
     * @param fn the function used to transform the contained value
     * @returns the mapped {@link Option}
     */
    map<U>(this: Option<T>, fn: (_: T) => U): Option<U> {
        switch (this.tag) {
            case Tag.Some: return Option.Some(fn(this.val))
            case Tag.None: return this as unknown as Option<U>
        }
    }

    /**
     * Maps this {@link Option} to a `U` instance by either calling `fn` on the contained value (if
     * any) or returning the given default value.
     *
     * @param this
     * @param def the default value to return in the {@link None} case
     * @param fn the function used to transform the contained value
     * @returns the transformed value or the given default
     */
    mapOr<U>(this: Option<T>, def: U, fn: (_: T) => U): U {
        switch (this.tag) {
            case Tag.Some: return fn(this.val)
            case Tag.None: return def
        }
    }

    /**
     * Maps this {@link Option} to a `U` instance by either calling `fn` on the contained value (if
     * any) or returning the default value generated by the given `def` function.
     *
     * The difference to {@link OptionBase.mapOr} is, that the default value is lazily generated
     * only if no value is contained in `this`.
     *
     * @param this
     * @param def the function generating the default value to return in the {@link None} case
     * @param fn the function used to transform the contained value
     * @returns the transformed value or the given default
     */
    mapOrElse<U>(this: Option<T>, def: () => U, fn: (_: T) => U): U {
        switch (this.tag) {
            case Tag.Some: return fn(this.val)
            case Tag.None: return def()
        }
    }

    /**
     * Transforms the {@link Option} into an {@link Ok} result or returns an {@link Err} wrapping
     * the given `err` value.
     *
     * @param this
     * @param err the error to return in the {@link None} case
     * @returns the appropriate {@link Result} variant instance
     */
    okOr<E>(this: Option<T>, err: E): Result<T, E> {
        switch (this.tag) {
            case Tag.Some: return Result.Ok(this.val)
            case Tag.None: return Result.Err(err)
        }
    }

    /**
     * Transform the {@link Option} into an {@link Ok} result or returns an {@link Err} wrapping the
     * result returned by `fn`.
     *
     * @param this
     * @param fn
     */
    okOrElse<E>(this: Option<T>, fn: () => E): Result<T, E> {
        switch (this.tag) {
            case Tag.Some: return Result.Ok(this.val)
            case Tag.None: return Result.Err(fn())
        }
    }

    /**
     * Performs a logical *and* on this and `other`, returning `other` if both are {@link Some} and
     * {@link None} otherwise.
     *
     * @param this
     * @param other
     */
    and<U>(this: Option<T>, other: Option<U>): Option<U> {
        switch (this.tag) {
            case Tag.Some: return other
            case Tag.None: return this as unknown as Option<U>
        }
    }

    andThen<U>(this: Option<T>, fn: (_: T) => Option<U>): Option<U> {
        switch (this.tag) {
            case Tag.Some: return fn(this.val)
            case Tag.None: return this as unknown as Option<U>
        }
    }

    or(this: Option<T>, other: Option<T>): Option<T> {
        switch (this.tag) {
            case Tag.Some: return this
            case Tag.None: return other
        }
    }

    orElse(this: Option<T>, fn: () => Option<T>): Option<T> {
        switch (this.tag) {
            case Tag.Some: return this
            case Tag.None: return fn()
        }
    }

    /**
     * Returns the contained value or throws a {@link NoneError} exception.
     *
     * @param this
     * @returns the contained value
     * @throws {@link NoneError} if `this` is a {@link None} variant.
     */
    unwrap(this: Option<T>): T | never {
        switch (this.tag) {
            case Tag.Some: return this.val
            case Tag.None: throw new NoneError()
        }
    }

    unwrapOr(this: Option<T>, def: T): T {
        switch (this.tag) {
            case Tag.Some: return this.val
            case Tag.None: return def
        }
    }

    unwrapOrElse(this: Option<T>, def: () => T): T {
        switch (this.tag) {
            case Tag.Some: return this.val
            case Tag.None: return def()
        }
    }

    expect(this: Option<T>, msg: string): T | never {
        switch (this.tag) {
            case Tag.Some: return this.val
            case Tag.None: throw new NoneError(msg)
        }
    }

    flatten(this: Option<Option<T>>): Option<T> {
        switch (this.tag) {
            case Tag.Some: return this.val
            case Tag.None: return Option.None
        }
    }

    transpose<E>(this: Option<Result<T, E>>): Result<Option<T>, E> {
        switch (this.tag) {
            case Tag.Some:
                switch (this.val.tag) {
                    case ResultTag.Ok: return Result.Ok(Option.Some(this.val.val))
                    case ResultTag.Err: return this.val as unknown as Result<Option<T>, E>
                }
            case Tag.None: return Result.Ok(Option.None)
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Tag
////////////////////////////////////////////////////////////////////////////////////////////////////

/** The {@link Option} discriminant tag type.  */
export const enum Tag { Some, None }

////////////////////////////////////////////////////////////////////////////////////////////////////
// Some
////////////////////////////////////////////////////////////////////////////////////////////////////

/** The {@link Option} variant containing a value. */
export class Some<T> extends OptionBase<T> {
    /** The discriminant tag. */
    readonly tag: Tag.Some
    /** The contained value. */
    readonly val: T

    static from<T>(val: T): Some<T> {
        return new Some(val)
    }

    private constructor(val: T) {
        super()
        this.tag = Tag.Some
        this.val = val
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// None
////////////////////////////////////////////////////////////////////////////////////////////////////

/** The {@link Option} variant containing no value. */
export class None<T> extends OptionBase<T> {
    /** The discriminant tag. */
    readonly tag: Tag.None = Tag.None

    static build(): None<never> {
        return new None()
    }

    private constructor() {
        super()
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Option
////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * The union type containing either a {@link Some} or a {@link None} variant.
 *
 * The discriminant field (`tag`) is of type {@link Tag} and (only) the {@link Some} variant
 * includes an additional `val` field.
 */
export type Option<T> = Some<T> | None<T>

/**
 * Associated (static) functions for creating {@link Option} instances.
 *
 * # Examples
 *
 * ```typescript
 * const some = Option.Some('string')
 * // prints `true`
 * console.log(some === Option.from('string))
 * const none: Option<string> = Option.None
 * // prints `true`
 * console.log(none === Option.from(null))
 * ```
 */
export const Option: {
    /**
     * Creates a new {@link Some} variant with the given `val`.
     *
     * @param val the (potentially nullish) value to be wrapped
     * @returns the {@link Some} variant
     */
    Some: <T>(val: T) => Option<T>,
    /**
     * A constant {@link None} instance that can be trivially copied to initialize other instances.
     */
    None: Option<never>,
    /**
     * Derives a new {@link Option} instance from the (potentially nullish) `val`.
     *
     * @param val the (potentially nullish) value to be wrapped
     * @returns the derived {@link Option} instance
     */
    from: <T>(val?: T | undefined | null) => Option<NonNullable<T>>
} = Object.freeze({
    Some<T>(val: T): Option<T> { return Some.from(val) },
    None: None.build(),
    from<T>(val?: T | undefined | null): Option<NonNullable<T>> {
        if (val !== undefined && val !== null) {
            return Option.Some(val as NonNullable<T>)
        } else {
            return Option.None
        }
    }
})

////////////////////////////////////////////////////////////////////////////////////////////////////
// NoneError
////////////////////////////////////////////////////////////////////////////////////////////////////

/** Error that is thrown when an attempt to `unwrap` a`None` variant is made. */
export class NoneError extends Error {
    constructor(msg?: string) {
        super(msg ?? 'called `unwrap` on `Option.None` value')
    }
}